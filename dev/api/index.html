<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · TermStructureModels.jl</title><meta name="title" content="API · TermStructureModels.jl"/><meta property="og:title" content="API · TermStructureModels.jl"/><meta property="twitter:title" content="API · TermStructureModels.jl"/><meta name="description" content="Documentation for TermStructureModels.jl."/><meta property="og:description" content="Documentation for TermStructureModels.jl."/><meta property="twitter:description" content="Documentation for TermStructureModels.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TermStructureModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Exported-Functions"><span>Exported Functions</span></a></li><li><a class="tocitem" href="#Internal-Functions"><span>Internal Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/econPreference/TermStructureModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/econPreference/TermStructureModels.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-documentation"><a class="docs-heading-anchor" href="#API-documentation">API documentation</a><a id="API-documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-documentation" title="Permalink"></a></h1><ul><li><a href="#API-documentation">API documentation</a></li><li class="no-marker"><ul><li><a href="#Index">Index</a></li><li><a href="#Exported-Functions">Exported Functions</a></li><li><a href="#Internal-Functions">Internal Functions</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#TermStructureModels.Forecast"><code>TermStructureModels.Forecast</code></a></li><li><a href="#TermStructureModels.Hyperparameter"><code>TermStructureModels.Hyperparameter</code></a></li><li><a href="#TermStructureModels.LatentSpace"><code>TermStructureModels.LatentSpace</code></a></li><li><a href="#TermStructureModels.Parameter"><code>TermStructureModels.Parameter</code></a></li><li><a href="#TermStructureModels.PosteriorSample"><code>TermStructureModels.PosteriorSample</code></a></li><li><a href="#TermStructureModels.ReducedForm"><code>TermStructureModels.ReducedForm</code></a></li><li><a href="#TermStructureModels.Scenario"><code>TermStructureModels.Scenario</code></a></li><li><a href="#TermStructureModels.TermPremium"><code>TermStructureModels.TermPremium</code></a></li><li><a href="#TermStructureModels.YieldCurve"><code>TermStructureModels.YieldCurve</code></a></li><li><a href="#Base.getindex-Tuple{PosteriorSample, Symbol}"><code>Base.getindex</code></a></li><li><a href="#Base.getindex-Tuple{Vector{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:PosteriorSample, Symbol}"><code>Base.getindex</code></a></li><li><a href="#Statistics.mean-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.mean</code></a></li><li><a href="#Statistics.median-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample}"><code>Statistics.median</code></a></li><li><a href="#Statistics.quantile-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample, Any}"><code>Statistics.quantile</code></a></li><li><a href="#Statistics.std-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.std</code></a></li><li><a href="#Statistics.var-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.var</code></a></li><li><a href="#TermStructureModels.AR_res_var-Tuple{Vector{T} where T, Any}"><code>TermStructureModels.AR_res_var</code></a></li><li><a href="#TermStructureModels.Aₓ-Tuple{Any, Any}"><code>TermStructureModels.Aₓ</code></a></li><li><a href="#TermStructureModels.Aₚ-NTuple{4, Any}"><code>TermStructureModels.Aₚ</code></a></li><li><a href="#TermStructureModels.Bₓ-Tuple{Any, Any}"><code>TermStructureModels.Bₓ</code></a></li><li><a href="#TermStructureModels.Bₚ-Tuple{Any, Any, Any}"><code>TermStructureModels.Bₚ</code></a></li><li><a href="#TermStructureModels.GQ_XX-Tuple{}"><code>TermStructureModels.GQ_XX</code></a></li><li><a href="#TermStructureModels.Kϕ-NTuple{4, Any}"><code>TermStructureModels.Kϕ</code></a></li><li><a href="#TermStructureModels.LDL-Tuple{Any}"><code>TermStructureModels.LDL</code></a></li><li><a href="#TermStructureModels.Minnesota-Tuple{Any, Any, Any}"><code>TermStructureModels.Minnesota</code></a></li><li><a href="#TermStructureModels.NIG_NIG-NTuple{6, Any}"><code>TermStructureModels.NIG_NIG</code></a></li><li><a href="#TermStructureModels.PCA"><code>TermStructureModels.PCA</code></a></li><li><a href="#TermStructureModels.PCs_2_latents-Tuple{Any, Any}"><code>TermStructureModels.PCs_2_latents</code></a></li><li><a href="#TermStructureModels.S-Tuple{Any}"><code>TermStructureModels.S</code></a></li><li><a href="#TermStructureModels.S_hat-NTuple{6, Any}"><code>TermStructureModels.S_hat</code></a></li><li><a href="#TermStructureModels.T0P-NTuple{4, Any}"><code>TermStructureModels.T0P</code></a></li><li><a href="#TermStructureModels.T1X-Tuple{Any, Any}"><code>TermStructureModels.T1X</code></a></li><li><a href="#TermStructureModels._conditional_forecasts-NTuple{6, Any}"><code>TermStructureModels._conditional_forecasts</code></a></li><li><a href="#TermStructureModels._scenario_analysis-NTuple{6, Any}"><code>TermStructureModels._scenario_analysis</code></a></li><li><a href="#TermStructureModels._scenario_analysis_unconditional-NTuple{5, Any}"><code>TermStructureModels._scenario_analysis_unconditional</code></a></li><li><a href="#TermStructureModels._termPremium-NTuple{6, Any}"><code>TermStructureModels._termPremium</code></a></li><li><a href="#TermStructureModels._unconditional_forecasts-NTuple{5, Any}"><code>TermStructureModels._unconditional_forecasts</code></a></li><li><a href="#TermStructureModels.aτ-NTuple{4, Any}"><code>TermStructureModels.aτ</code></a></li><li><a href="#TermStructureModels.bτ-Tuple{Any}"><code>TermStructureModels.bτ</code></a></li><li><a href="#TermStructureModels.calibrate_μϕ_const-NTuple{7, Any}"><code>TermStructureModels.calibrate_μϕ_const</code></a></li><li><a href="#TermStructureModels.conditional_forecasts-NTuple{7, Any}"><code>TermStructureModels.conditional_forecasts</code></a></li><li><a href="#TermStructureModels.dcurvature_dτ-Tuple{Any}"><code>TermStructureModels.dcurvature_dτ</code></a></li><li><a href="#TermStructureModels.dimQ-Tuple{}"><code>TermStructureModels.dimQ</code></a></li><li><a href="#TermStructureModels.erase_nonstationary_param-Tuple{Any}"><code>TermStructureModels.erase_nonstationary_param</code></a></li><li><a href="#TermStructureModels.fitted_YieldCurve-Tuple{Any, Vector{LatentSpace}}"><code>TermStructureModels.fitted_YieldCurve</code></a></li><li><a href="#TermStructureModels.generative-Tuple{Any, Any, Any, Any, Float64}"><code>TermStructureModels.generative</code></a></li><li><a href="#TermStructureModels.isstationary-Tuple{Any}"><code>TermStructureModels.isstationary</code></a></li><li><a href="#TermStructureModels.jensens_inequality-Tuple{Any, Any, Any}"><code>TermStructureModels.jensens_inequality</code></a></li><li><a href="#TermStructureModels.latentspace-Tuple{Any, Any, Any}"><code>TermStructureModels.latentspace</code></a></li><li><a href="#TermStructureModels.log_marginal-Tuple{Any, Any, Any, Hyperparameter, Any, Any}"><code>TermStructureModels.log_marginal</code></a></li><li><a href="#TermStructureModels.loglik_mea-Tuple{Any, Any}"><code>TermStructureModels.loglik_mea</code></a></li><li><a href="#TermStructureModels.loglik_tran-Tuple{Any, Any}"><code>TermStructureModels.loglik_tran</code></a></li><li><a href="#TermStructureModels.post_kQ_infty-NTuple{4, Any}"><code>TermStructureModels.post_kQ_infty</code></a></li><li><a href="#TermStructureModels.post_Σₒ-Tuple{Any, Any}"><code>TermStructureModels.post_Σₒ</code></a></li><li><a href="#TermStructureModels.post_γ-Tuple{}"><code>TermStructureModels.post_γ</code></a></li><li><a href="#TermStructureModels.post_κQ-Tuple{Any, Any, Any}"><code>TermStructureModels.post_κQ</code></a></li><li><a href="#TermStructureModels.post_ϕ_σ²FF-NTuple{6, Any}"><code>TermStructureModels.post_ϕ_σ²FF</code></a></li><li><a href="#TermStructureModels.posterior_sampler-Tuple{Any, Any, Any, Any, Any, Hyperparameter}"><code>TermStructureModels.posterior_sampler</code></a></li><li><a href="#TermStructureModels.prior_C-Tuple{}"><code>TermStructureModels.prior_C</code></a></li><li><a href="#TermStructureModels.prior_γ-Tuple{Any, Any}"><code>TermStructureModels.prior_γ</code></a></li><li><a href="#TermStructureModels.prior_κQ-Tuple{Any, Any}"><code>TermStructureModels.prior_κQ</code></a></li><li><a href="#TermStructureModels.prior_σ²FF-Tuple{}"><code>TermStructureModels.prior_σ²FF</code></a></li><li><a href="#TermStructureModels.prior_ϕ0-Tuple{Any, Vector{T} where T, Any, Any, Any}"><code>TermStructureModels.prior_ϕ0</code></a></li><li><a href="#TermStructureModels.reducedform-NTuple{4, Any}"><code>TermStructureModels.reducedform</code></a></li><li><a href="#TermStructureModels.scenario_analysis-Tuple{Vector{T} where T, Any, Any, Any, Any, Any, Any}"><code>TermStructureModels.scenario_analysis</code></a></li><li><a href="#TermStructureModels.term_premium-NTuple{5, Any}"><code>TermStructureModels.term_premium</code></a></li><li><a href="#TermStructureModels.tuning_hyperparameter-NTuple{4, Any}"><code>TermStructureModels.tuning_hyperparameter</code></a></li><li><a href="#TermStructureModels.yϕ_Xϕ-Tuple{Any, Any, Any}"><code>TermStructureModels.yϕ_Xϕ</code></a></li><li><a href="#TermStructureModels.ν-Tuple{Any, Any}"><code>TermStructureModels.ν</code></a></li><li><a href="#TermStructureModels.ϕ_2_ϕ₀_C-Tuple{}"><code>TermStructureModels.ϕ_2_ϕ₀_C</code></a></li><li><a href="#TermStructureModels.ϕ_hat-NTuple{6, Any}"><code>TermStructureModels.ϕ_hat</code></a></li><li><a href="#TermStructureModels.ϕ_σ²FF_2_ΩFF-Tuple{}"><code>TermStructureModels.ϕ_σ²FF_2_ΩFF</code></a></li><li><a href="#TermStructureModels.ϕ_σ²FF_2_ΩPP-Tuple{}"><code>TermStructureModels.ϕ_σ²FF_2_ΩPP</code></a></li></ul><h2 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Forecast" href="#TermStructureModels.Forecast"><code>TermStructureModels.Forecast</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@kwdef struct Forecast &lt;: PosteriorSample</code></pre><p>It contains a result of the scenario analysis, the conditional prediction for yields, <code>factors = [PCs macros]</code>, and term premiums.</p><ul><li><code>yields</code></li><li><code>factors</code></li><li><code>TP</code>: term premium forecasts</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/TermStructureModels.jl#L138-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Hyperparameter" href="#TermStructureModels.Hyperparameter"><code>TermStructureModels.Hyperparameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@kwdef struct Hyperparameter</code></pre><ul><li><code>p::Int</code></li><li><code>q::Matrix</code></li><li><code>ν0</code></li><li><code>Ω0::Vector</code></li><li><code>μϕ_const::Vector = zeros(length(Ω0))</code>: It is a prior mean of a constant term in our VAR.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/TermStructureModels.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.LatentSpace" href="#TermStructureModels.LatentSpace"><code>TermStructureModels.LatentSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@kwdef struct LatentSpace &lt;: PosteriorSample</code></pre><p>When the model goes to the JSZ latent factor space, the statistical parameters in struct Parameter are also transformed. This struct contains the transformed parameters. Specifically, the transformation is <code>latents[t,:] = T0P_ + inv(T1X)*PCs[t,:]</code>. </p><p>In the latent factor space, the transition equation is <code>data[t,:] = KₚXF + GₚXFXF*vec(data[t-1:-1:t-p,:]&#39;) + MvNormal(O,ΩXFXF)</code>, where <code>data = [latent macros]</code>.</p><ul><li><code>latents::Matrix</code></li><li><code>κQ</code></li><li><code>kQ_infty</code></li><li><code>KₚXF::Vector</code></li><li><code>GₚXFXF::Matrix</code></li><li><code>ΩXFXF::Matrix</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/TermStructureModels.jl#L74-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Parameter" href="#TermStructureModels.Parameter"><code>TermStructureModels.Parameter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@kwdef struct Parameter &lt;: PosteriorSample</code></pre><p>It contains statistical parameters of the model that are sampled from function <code>posterior_sampler</code>.</p><ul><li><code>κQ::Float64</code></li><li><code>kQ_infty::Float64</code></li><li><code>ϕ::Matrix{Float64}</code></li><li><code>σ²FF::Vector{Float64}</code></li><li><code>Σₒ::Vector{Float64}</code></li><li><code>γ::Vector{Float64}</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/TermStructureModels.jl#L30-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.PosteriorSample" href="#TermStructureModels.PosteriorSample"><code>TermStructureModels.PosteriorSample</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">abstract type PosteriorSample</code></pre><p>It is a super-set of structs <code>Parameter</code>, <code>ReducedForm</code>, <code>LatentSpace</code>, <code>YieldCurve</code>, <code>TermPremium</code>, <code>Forecast</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/TermStructureModels.jl#L24-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.ReducedForm" href="#TermStructureModels.ReducedForm"><code>TermStructureModels.ReducedForm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@kwdef struct ReducedForm &lt;: PosteriorSample</code></pre><p>It contains statistical parameters in terms of the reduced form VAR(p) in P-dynamics. <code>λP</code> and <code>ΛPF</code> are parameters in the market prices of risks equation, and they only contain the first <code>dQ</code> non-zero equations. </p><ul><li><code>κQ</code></li><li><code>kQ_infty</code></li><li><code>KₚF</code></li><li><code>GₚFF</code></li><li><code>ΩFF::Matrix</code></li><li><code>Σₒ::Vector</code></li><li><code>λP</code></li><li><code>ΛPF</code></li><li><code>mpr::Matrix(</code>market prices of risks<code>, T, dP)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/TermStructureModels.jl#L49-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Scenario" href="#TermStructureModels.Scenario"><code>TermStructureModels.Scenario</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@kwdef struct Scenario</code></pre><p>It contains scenarios to be conditioned in the scenario analysis. When <code>y = [yields; macros]</code> is a observed vector in our measurement equation, <code>Scenario.combinations*y = Scenario.values</code> constitutes the scenario at a specific time. <code>Vector{Scenario}</code> is used to describe a time-series of scenarios.</p><p><code>combinations</code> and <code>values</code> should be <code>Matrix</code> and <code>Vector</code>. If <code>values</code> is a scalar, <code>combinations</code> would be a matrix with one raw vector and <code>values</code> should be one-dimensional vector, for example [values]. </p><ul><li><code>combinations::Matrix</code></li><li><code>values::Vector</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/TermStructureModels.jl#L125-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.TermPremium" href="#TermStructureModels.TermPremium"><code>TermStructureModels.TermPremium</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@kwdef struct TermPremium &lt;: PosteriorSample</code></pre><p>It contains a estimated time series of a term premium for one maturity.</p><ul><li><code>TP::Vector</code>: term premium estimates of a specific maturity bond. <code>TP = timevarying_TP + const_TP + jensen</code> holds.</li><li><code>timevarying_TP::Matrix</code>: rows:time, cols:factors, values: contributions of factors on TP</li><li><code>const_TP::Float64</code>: constant part in TP</li><li><code>jensen::Float64</code>: the part due to the Jensen&#39;s inequality</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/TermStructureModels.jl#L110-L117">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.YieldCurve" href="#TermStructureModels.YieldCurve"><code>TermStructureModels.YieldCurve</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@kwdef struct YieldCurve &lt;: PosteriorSample</code></pre><p>It contains a fitted yield curve. <code>yields[t,:] = intercept + slope*latents[t,:]</code> holds.</p><ul><li><code>latents::Matrix</code>: latent pricing factors in LatentSpace</li><li><code>yields</code></li><li><code>intercept</code></li><li><code>slope</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/TermStructureModels.jl#L95-L102">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{PosteriorSample, Symbol}" href="#Base.getindex-Tuple{PosteriorSample, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(x::PosteriorSample, c::Symbol)</code></pre><p>For <code>struct &lt;: PosteriorSample</code>, <code>struct[:name]</code> calls objects in struct.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/utilities.jl#L9-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.getindex-Tuple{Vector{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:PosteriorSample, Symbol}" href="#Base.getindex-Tuple{Vector{var&quot;#s13&quot;} where var&quot;#s13&quot;&lt;:PosteriorSample, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getindex(x::Vector{&lt;:PosteriorSample}, c::Symbol)</code></pre><p>For <code>struct &lt;: PosteriorSample</code>, <code>struct[:name]</code> calls objects in <code>struct</code>. <code>Output[i]</code> = <span>$i&#39;$</span>th posterior sample</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/utilities.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.mean-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}" href="#Statistics.mean-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mean(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior mean.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/utilities.jl#L17-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.median-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample}" href="#Statistics.median-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample}"><code>Statistics.median</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">median(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior median.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/utilities.jl#L30-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.quantile-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample, Any}" href="#Statistics.quantile-Tuple{Vector{var&quot;#s7&quot;} where var&quot;#s7&quot;&lt;:PosteriorSample, Any}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">quantile(x::Vector{&lt;:PosteriorSample}, q)</code></pre><p><code>Output[:variable name]</code> returns a quantile of the corresponding posterior distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/utilities.jl#L78-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.std-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}" href="#Statistics.std-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">std(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior standard deviation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/utilities.jl#L52-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Statistics.var-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}" href="#Statistics.var-Tuple{Vector{var&quot;#s12&quot;} where var&quot;#s12&quot;&lt;:PosteriorSample}"><code>Statistics.var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">var(x::Vector{&lt;:PosteriorSample})</code></pre><p><code>Output[:variable name]</code> returns the corresponding posterior variance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/utilities.jl#L65-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.AR_res_var-Tuple{Vector{T} where T, Any}" href="#TermStructureModels.AR_res_var-Tuple{Vector{T} where T, Any}"><code>TermStructureModels.AR_res_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">AR_res_var(TS::Vector, p)</code></pre><p>It derives an MLE error variance estimate of an AR(<code>p</code>) model</p><p><strong>Input</strong></p><ul><li>univariate time series <code>TS</code> and the lag <code>p</code></li></ul><p><strong>output(2)</strong></p><p>residual variance estimate, AR(p) coefficients</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/inference.jl#L120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.GQ_XX-Tuple{}" href="#TermStructureModels.GQ_XX-Tuple{}"><code>TermStructureModels.GQ_XX</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">GQ_XX(; κQ)</code></pre><p><code>κQ</code> governs a conditional mean of the Q-dynamics of <code>X</code>, and its slope matrix has a restricted form. This function shows that restricted form.</p><p><strong>Output</strong></p><ul><li>slope matrix of the Q-conditional mean of <code>X</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.LDL-Tuple{Any}" href="#TermStructureModels.LDL-Tuple{Any}"><code>TermStructureModels.LDL</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">LDL(X)</code></pre><p>This function generate a matrix decomposition, called LDLt. <code>X = L*D*L&#39;</code>, where <code>L</code> is a lower triangular matrix and <code>D</code> is a diagonal. How to conduct it can be found at <a href="https://en.wikipedia.org/wiki/Cholesky_decomposition#LDL_decomposition">Wikipedia</a>.</p><p><strong>Input</strong></p><ul><li>Decomposed Object, <code>X</code></li></ul><p><strong>Output(2)</strong></p><p><code>L</code>, <code>D</code></p><ul><li>Decomposed result is <code>X = L*D*L&#39;</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L90-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.PCA" href="#TermStructureModels.PCA"><code>TermStructureModels.PCA</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">PCA(yields, p, proxies=[]; rescaling=false)</code></pre><p>It derives the principal components from <code>yields</code>.</p><p><strong>Input</strong></p><ul><li><code>yields[p+1:end, :]</code> is used to construct the affine transformation, and then all <code>yields[:,:]</code> are transformed into the principal components.</li><li>Since signs of <code>PCs</code> is not identified, we use proxies to identify the signs. We flip <code>PCs</code> to make <code>cor(proxies[:, i]. PCs[:,i]) &gt; 0</code>. If <code>proxies</code> is not given, we use the following proxies as a default: <code>[yields[:, end] yields[:, end] - yields[:, 1] 2yields[:, Int(floor(size(yields, 2) / 3))] - yields[:, 1] - yields[:, end]]</code>.</li><li><code>size(proxies) = (size(yields[p+1:end, :], 1), dQ)</code></li><li>If <code>rescaling == true</code>, all <code>PCs</code> and <code>OCs</code> are normalized to have an average std of yields.</li></ul><p><strong>Output(4)</strong></p><p><code>PCs</code>, <code>OCs</code>, <code>Wₚ</code>, <code>Wₒ</code>, <code>mean_PCs</code></p><ul><li><code>PCs</code>, <code>OCs</code>: first <code>dQ</code> and the remaining principal components</li><li><code>Wₚ</code>, <code>Wₒ</code>: the rotation matrix for <code>PCs</code> and <code>OCs</code>, respectively</li><li><code>mean_PCs</code>: the mean of <code>PCs</code> before demeaned.</li><li><code>PCs</code> are demeaned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L426-L440">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.calibrate_μϕ_const-NTuple{7, Any}" href="#TermStructureModels.calibrate_μϕ_const-NTuple{7, Any}"><code>TermStructureModels.calibrate_μϕ_const</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">calibrate_μϕ_const(μkQ_infty, σkQ_infty, ν0, yields, macros, τₙ, p; μϕ_const_PCs=[], medium_τ=collect(30:2:48), iteration=1000, data_scale=1200, medium_τ_pr=[], τ=[])</code></pre><p>The purpose of the function is to calibrate a prior mean of the first <code>dQ</code> constant terms in our VAR. Adjust your prior setting based on the prior samples in outputs.</p><p><strong>Input</strong></p><ul><li><code>μϕ_const_PCs</code> is your prior mean of the first <code>dQ</code> constants. Our default option set it as a zero vector.</li></ul><p>_ iteration is the number of prior samples.</p><ul><li><code>τ::scalar</code> is a maturity for calculating the constant part in the term premium.<ul><li>If τ is empty, the function does not sampling the prior distribution of the constant part in the term premium.</li></ul></li></ul><p><strong>Output(2)</strong></p><p>prior<em>λₚ, prior</em>TP</p><ul><li>samples from the prior distribution of <code>λₚ</code> </li><li>prior samples of constant part in the τ-month term premium</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L276-L288">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.conditional_forecasts-NTuple{7, Any}" href="#TermStructureModels.conditional_forecasts-NTuple{7, Any}"><code>TermStructureModels.conditional_forecasts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">conditional_forecasts(S::Vector, τ, horizon, saved_θ, yields, macros, τₙ; mean_macros::Vector=[], data_scale=1200)</code></pre><p><strong>Input</strong></p><p>scenarios, a result of the posterior sampler, and data </p><ul><li><code>S[t]</code> = conditioned scenario at time <code>size(yields, 1)+t</code>.<ul><li>If we need an unconditional prediction, <code>S = []</code>.</li><li>If you are conditionaing a scenario, I assume S = Vector{Scenario}.</li></ul></li><li><code>τ</code> is a vector of maturities that term premiums of interest has.</li><li><code>horizon</code>: maximum length of the predicted path. It should not be small than <code>length(S)</code>.</li><li><code>saved_θ</code>: the first output of function <code>posterior_sampler</code>.</li><li><code>mean_macros::Vector</code>: If you demeaned macro variables, you can input the mean of the macro variables. Then, the output will be generated in terms of the un-demeaned macro variables.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{Forecast}(, iteration)</code></li><li><code>t</code>&#39;th rows in predicted <code>yields</code>, predicted <code>factors</code>, and predicted <code>TP</code> are the corresponding predicted value at time <code>size(yields, 1)+t</code>.</li><li>Mathematically, it is a posterior samples from <code>future observation|past observation,scenario</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/scenario.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.dcurvature_dτ-Tuple{Any}" href="#TermStructureModels.dcurvature_dτ-Tuple{Any}"><code>TermStructureModels.dcurvature_dτ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dcurvature_dτ(τ; κQ)</code></pre><p>This function calculate the first derivative of the curvature factor loading w.r.t. the maturity.</p><p><strong>Input</strong></p><ul><li><code>κQ</code>: The decay parameter</li><li><code>τ</code>: The maturity that the derivative is calculated</li></ul><p><strong>Output</strong></p><ul><li>the first derivative of the curvature factor loading w.r.t. the maturity</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/prior.jl#L177-L185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.dimQ-Tuple{}" href="#TermStructureModels.dimQ-Tuple{}"><code>TermStructureModels.dimQ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dimQ()</code></pre><p>It returns the dimension of Q-dynamics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L16-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.erase_nonstationary_param-Tuple{Any}" href="#TermStructureModels.erase_nonstationary_param-Tuple{Any}"><code>TermStructureModels.erase_nonstationary_param</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">erase_nonstationary_param(saved_θ)</code></pre><p>It filters out posterior samples that implies an unit root VAR system. Only stationary posterior samples remain.</p><p><strong>Input</strong></p><ul><li><code>saved_θ</code> is the first output of function <code>posterior_sampler</code>.</li></ul><p><strong>Output(2):</strong></p><p>stationary samples, acceptance rate(%)</p><ul><li>The second output indicates how many posterior samples remain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L172-L181">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.fitted_YieldCurve-Tuple{Any, Vector{LatentSpace}}" href="#TermStructureModels.fitted_YieldCurve-Tuple{Any, Vector{LatentSpace}}"><code>TermStructureModels.fitted_YieldCurve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fitted_YieldCurve(τ0, saved_Xθ::Vector{LatentSpace}; data_scale=1200)</code></pre><p>It generates a fitted yield curve.</p><p><strong>Input</strong></p><ul><li><code>τ0</code> is a set of maturities of interest. <code>τ0</code> does not need to be the same as the one used for the estimation.</li><li><code>saved_Xθ</code> is a transformed posterior sample using function <code>latentspace</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{YieldCurve}(,</code># of iteration<code>)</code></li><li><code>yields</code> and <code>latents</code> contain initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L383-L392">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.generative-Tuple{Any, Any, Any, Any, Float64}" href="#TermStructureModels.generative-Tuple{Any, Any, Any, Any, Float64}"><code>TermStructureModels.generative</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generative(T, dP, τₙ, p, noise::Float64; κQ, kQ_infty, KₚXF, GₚXFXF, ΩXFXF, data_scale=1200)</code></pre><p>This function generate a simulation data given parameters. Note that all parameters are the things in the latent factor state space (that is, parameters in struct LatentSpace). There is some differences in notations because it is hard to express mathcal letters in VScode. So, mathcal{F} in my paper is expressed in <code>F</code> in the VScode. And, &quot;F&quot; in my paper is expressed as <code>XF</code>.</p><p><strong>Input:</strong></p><ul><li>noise = variance of the measurement errors</li></ul><p><strong>Output(3)</strong></p><p><code>yields</code>, <code>latents</code>, <code>macros</code></p><ul><li><code>yields = Matrix{Float64}(obs,T,length(τₙ))</code></li><li><code>latents = Matrix{Float64}(obs,T,dimQ())</code></li><li><code>macros = Matrix{Float64}(obs,T,dP - dimQ())</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/inference.jl#L214-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.isstationary-Tuple{Any}" href="#TermStructureModels.isstationary-Tuple{Any}"><code>TermStructureModels.isstationary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isstationary(GₚFF)</code></pre><p>It checks whether a reduced VAR matrix has unit roots. If there is at least one unit root, return is false.</p><p><strong>Input</strong></p><ul><li><code>GₚFF</code> should not include intercepts. Also, <code>GₚFF</code> is <code>dP</code> by <code>dP*p</code> matrix that the coefficient at lag 1 comes first, and the lag <code>p</code> slope matrix comes last. </li></ul><p><strong>Output</strong></p><ul><li><code>boolean</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L154-L161">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.latentspace-Tuple{Any, Any, Any}" href="#TermStructureModels.latentspace-Tuple{Any, Any, Any}"><code>TermStructureModels.latentspace</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">latentspace(saved_θ, yields, τₙ; data_scale=1200)</code></pre><p>This function translates the principal components state space into the latent factor state space. </p><p><strong>Input</strong></p><ul><li><code>data_scale::scalar</code>: In typical affine term structure model, theoretical yields are in decimal and not annualized. But, for convenience(public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{LatentSpace}(, iteration)</code></li><li>latent factors contain initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L287-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.log_marginal-Tuple{Any, Any, Any, Hyperparameter, Any, Any}" href="#TermStructureModels.log_marginal-Tuple{Any, Any, Any, Hyperparameter, Any, Any}"><code>TermStructureModels.log_marginal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_marginal(PCs, macros, ρ, tuned::Hyperparameter, τₙ, Wₚ; ψ=[], ψ0=[], medium_τ, medium_τ_pr, fix_const_PC1)</code></pre><p>This file calculates a value of our marginal likelihood. Only the transition equation is used to calculate it. </p><p><strong>Input</strong></p><ul><li>tuned is a point where the marginal likelihood is evaluated. 	</li><li><code>ψ0</code> and <code>ψ</code> are multiplied with prior variances of coefficients of the intercept and lagged regressors in the orthogonalized transition equation. They are used for imposing zero prior variances. A empty default value means that you do not use this function. <code>[ψ0 ψ][i,j]</code> is corresponds to <code>ϕ[i,j]</code>. </li></ul><p><strong>Output</strong></p><ul><li>the log marginal likelihood of the VAR system.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/EB_marginal.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.loglik_mea-Tuple{Any, Any}" href="#TermStructureModels.loglik_mea-Tuple{Any, Any}"><code>TermStructureModels.loglik_mea</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loglik_mea(yields, τₙ; κQ, kQ_infty, ϕ, σ²FF, Σₒ, data_scale)</code></pre><p>This function generate a log likelihood of the measurement equation.</p><p><strong>Output</strong></p><ul><li>the measurement equation part of the log likelihood</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.loglik_tran-Tuple{Any, Any}" href="#TermStructureModels.loglik_tran-Tuple{Any, Any}"><code>TermStructureModels.loglik_tran</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">loglik_tran(PCs, macros; ϕ, σ²FF)</code></pre><p>It calculate log likelihood of the transition equation. </p><p><strong>Output</strong></p><ul><li>log likelihood of the transition equation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L37-L42">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.posterior_sampler-Tuple{Any, Any, Any, Any, Any, Hyperparameter}" href="#TermStructureModels.posterior_sampler-Tuple{Any, Any, Any, Any, Any, Hyperparameter}"><code>TermStructureModels.posterior_sampler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">posterior_sampler(yields, macros, τₙ, ρ, iteration, tuned::Hyperparameter; medium_τ=collect(30:2:48), init_param=[], ψ=[], ψ0=[], γ_bar=[], medium_τ_pr=[], μkQ_infty=0, σkQ_infty=0.1, fix_const_PC1=false, data_scale=1200)</code></pre><p>This is a posterior distribution sampler.</p><p><strong>Input</strong></p><ul><li><code>iteration</code>: # of posterior samples</li><li><code>tuned</code>: optimized hyperparameters used during estimation</li><li><code>init_param</code>: starting point of the sampler. It should be a type of Parameter.</li></ul><p><strong>Output(2)</strong></p><p><code>Vector{Parameter}(posterior, iteration)</code>, acceptance rate of the MH algorithm</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/inference.jl#L140-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.prior_κQ-Tuple{Any, Any}" href="#TermStructureModels.prior_κQ-Tuple{Any, Any}"><code>TermStructureModels.prior_κQ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prior_κQ(medium_τ, pr)</code></pre><p>The function derive the maximizer decay parameter <code>κQ</code> that maximize the curvature factor loading at each candidate medium-term maturity. And then, it impose a discrete prior distribution on the maximizers with a prior probability vector <code>pr</code>.</p><p><strong>Input</strong></p><ul><li><code>medium_τ::Vector</code>(candidate medium maturities, # of candidates)</li><li><code>pr::Vector</code>(probability, # of candidates)</li></ul><p><strong>Output</strong></p><ul><li>discrete prior distribution that has a support of the maximizers <code>κQ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/prior.jl#L154-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.reducedform-NTuple{4, Any}" href="#TermStructureModels.reducedform-NTuple{4, Any}"><code>TermStructureModels.reducedform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reducedform(saved_θ, yields, macros, τₙ; data_scale=1200)</code></pre><p>It converts posterior samples in terms of the reduced form VAR parameters.</p><p><strong>Input</strong></p><ul><li><code>saved_θ</code> is the first output of function <code>posterior_sampler</code>.</li></ul><p><strong>Output</strong></p><ul><li>Posterior samples in terms of struct <code>ReducedForm</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L210-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.scenario_analysis-Tuple{Vector{T} where T, Any, Any, Any, Any, Any, Any}" href="#TermStructureModels.scenario_analysis-Tuple{Vector{T} where T, Any, Any, Any, Any, Any, Any}"><code>TermStructureModels.scenario_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scenario_analysis(S::Vector, τ, horizon, saved_θ, yields, macros, τₙ; mean_macros::Vector=[], data_scale=1200)</code></pre><p><strong>Input</strong></p><p>scenarios, a result of the posterior sampler, and data </p><ul><li><code>S[t]</code> = conditioned scenario at time <code>size(yields, 1)+t</code>.<ul><li>Set <code>S = []</code> if you need an unconditional prediction. </li><li>If you are conditionaing a scenario, I assume S = Vector{Scenario}.</li></ul></li><li><code>τ</code> is a vector of maturities that term premiums of interest has.</li><li><code>horizon</code>: maximum length of the predicted path. It should not be small than <code>length(S)</code>.</li><li><code>saved_θ</code>: the first output of function <code>posterior_sampler</code>.</li><li><code>mean_macros::Vector</code>: If you demeaned macro variables, you can input the mean of the macro variables. Then, the output will be generated in terms of the un-demeaned macro variables.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector{Forecast}(, iteration)</code></li><li><code>t</code>&#39;th rows in predicted <code>yields</code>, predicted <code>factors</code>, and predicted <code>TP</code> are the corresponding predicted value at time <code>size(yields, 1)+t</code>.</li><li>Mathematically, it is a posterior distribution of <code>E[future obs|past obs, scenario, parameters]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/scenario.jl#L306-L321">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.term_premium-NTuple{5, Any}" href="#TermStructureModels.term_premium-NTuple{5, Any}"><code>TermStructureModels.term_premium</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">term_premium(τ, τₙ, saved_θ, yields, macros; data_scale=1200)</code></pre><p>This function generates posterior samples of the term premiums.</p><p><strong>Input</strong></p><ul><li>maturity of interest <code>τ</code> for Calculating <code>TP</code></li><li><code>saved_θ</code> from function <code>posterior_sampler</code></li></ul><p><strong>Output</strong></p><ul><li><code>Vector{TermPremium}(, iteration)</code></li><li>Outputs exclude initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L234-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.tuning_hyperparameter-NTuple{4, Any}" href="#TermStructureModels.tuning_hyperparameter-NTuple{4, Any}"><code>TermStructureModels.tuning_hyperparameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tuning_hyperparameter(yields, macros, τₙ, ρ; populationsize=50, maxiter=10_000, medium_τ=collect(30:2:48), upper_q=[1 1; 1 1; 10 10; 100 100], μkQ_infty=0, σkQ_infty=0.1, upper_ν0=[], μϕ_const=[], fix_const_PC1=false, upper_p=18, μϕ_const_PC1=[], data_scale=1200, medium_τ_pr=[], init_ν0=[])</code></pre><p>It optimizes our hyperparameters by maximizing the marginal likelhood of the transition equation. Our optimizer is a differential evolutionary algorithm that utilizes bimodal movements in the eigen-space(Wang, Li, Huang, and Li, 2014) and the trivial geography(Spector and Klein, 2006).</p><p><strong>Input</strong></p><ul><li>When we compare marginal likelihoods between models, the data for the dependent variable should be the same across the models. To achieve that, we set a period of dependent variable based on upper<em>p. For example, if upper</em>p = 3, yields[4:end,:] and macros[4:end,:] are the data for our dependent variable. yields[1:3,:] and macros[1:3,:] are used for setting initial observations for all lags.</li><li><code>populationsize</code> and <code>maxiter</code> is a option for the optimizer.</li><li>The lower bounds for <code>q</code> and <code>ν0</code> are <code>0</code> and <code>dP+2</code>. </li><li>The upper bounds for <code>q</code>, <code>ν0</code> and VAR lag can be set by <code>upper_q</code>, <code>upper_ν0</code>, <code>upper_p</code>.<ul><li>Our default option for <code>upper_ν0</code> is the time-series length of the data.</li></ul></li><li>If you use our default option for <code>μϕ_const</code>,<ol><li><code>μϕ_const[dQ+1:end]</code> is a zero vector.</li><li><code>μϕ_const[1:dQ]</code> is calibrated to make a prior mean of <code>λₚ</code> a zero vector.</li><li>After step 2, <code>μϕ_const[1]</code> is replaced with <code>μϕ_const_PC1</code> if it is not empty.</li></ol></li><li><code>μϕ_const = Matrix(your prior, dP, upper_p)</code> </li><li><code>μϕ_const[:,i]</code> is a prior mean for the VAR(<code>i</code>) constant. Therefore μϕ<em>const is a matrix only in this function. In other functions, `μϕ</em>const` is a vector for the orthogonalized VAR system with your selected lag.</li><li>When <code>fix_const_PC1==true</code>, the first element in a constant term in our orthogonalized VAR is fixed to its prior mean during the posterior sampling.</li><li><code>data_scale::scalar</code>: In typical affine term structure model, theoretical yields are in decimal and not annualized. But, for convenience(public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output(2)</strong></p><p>optimized Hyperparameter, optimization result</p><ul><li>Be careful that we minimized the negative log marginal likelihood, so the second output is about the minimization problem.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/inference.jl#L2-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.ϕ_2_ϕ₀_C-Tuple{}" href="#TermStructureModels.ϕ_2_ϕ₀_C-Tuple{}"><code>TermStructureModels.ϕ_2_ϕ₀_C</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ϕ_2_ϕ₀_C(; ϕ)</code></pre><p>It divide ϕ into the lagged regressor part and the contemporaneous regerssor part.</p><p><strong>Output(3)</strong></p><p><code>ϕ0</code>, <code>C = C0 + I</code>, <code>C0</code></p><ul><li><code>ϕ0</code>: coefficients for the lagged regressors</li><li><code>C</code>: coefficients for the dependent variables when all contemporaneous variables are in the LHS of the orthogonalized equations. Therefore, the diagonals of <code>C</code> is ones. Note that since the contemporaneous variables get negative signs when they are at the RHS, the signs of <code>C</code> do not change whether they are at the RHS or LHS. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L124-L131">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.ϕ_σ²FF_2_ΩFF-Tuple{}" href="#TermStructureModels.ϕ_σ²FF_2_ΩFF-Tuple{}"><code>TermStructureModels.ϕ_σ²FF_2_ΩFF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ϕ_σ²FF_2_ΩFF(; ϕ, σ²FF)</code></pre><p>It construct <code>ΩFF</code> from statistical parameters.</p><p><strong>Output</strong></p><ul><li><code>ΩFF</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L142-L147">source</a></section></article><h2 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Aₓ-Tuple{Any, Any}" href="#TermStructureModels.Aₓ-Tuple{Any, Any}"><code>TermStructureModels.Aₓ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Aₓ(aτ_, τₙ)</code></pre><p><strong>Input</strong></p><ul><li><code>aτ_</code> is an output of function <code>aτ</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Aₓ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Aₚ-NTuple{4, Any}" href="#TermStructureModels.Aₚ-NTuple{4, Any}"><code>TermStructureModels.Aₚ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Aₚ(Aₓ_, Bₓ_, T0P_, Wₒ)</code></pre><p><strong>Input</strong></p><ul><li><code>Aₓ_</code>, <code>Bₓ_</code>, and <code>T0P_</code> are outputs of function <code>Aₓ</code>, <code>Bₓ</code>, and <code>T0P</code>, respectively.</li></ul><p><strong>Output</strong></p><ul><li><code>Aₚ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L139-L145">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Bₓ-Tuple{Any, Any}" href="#TermStructureModels.Bₓ-Tuple{Any, Any}"><code>TermStructureModels.Bₓ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Bₓ(bτ_, τₙ)</code></pre><p><strong>Input</strong></p><ul><li><code>bτ_</code> is an output of function <code>bτ</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Bₓ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L43-L49">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Bₚ-Tuple{Any, Any, Any}" href="#TermStructureModels.Bₚ-Tuple{Any, Any, Any}"><code>TermStructureModels.Bₚ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Bₚ(Bₓ_, T1X_, Wₒ)</code></pre><p><strong>Input</strong></p><ul><li><code>Bₓ_</code> and <code>T1X_</code> are outputs of function <code>Bₓ</code> and <code>T1X</code>, respectively.</li></ul><p><strong>Output</strong></p><ul><li><code>Bₚ</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L150-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Kϕ-NTuple{4, Any}" href="#TermStructureModels.Kϕ-NTuple{4, Any}"><code>TermStructureModels.Kϕ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Kϕ(i, V, Xϕ, dP)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/EB_marginal.jl#L73-L75">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.Minnesota-Tuple{Any, Any, Any}" href="#TermStructureModels.Minnesota-Tuple{Any, Any, Any}"><code>TermStructureModels.Minnesota</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Minnesota(l, i, j; q, ν0, Ω0)</code></pre><p>It return unscaled prior variance of the Minnesota prior.</p><p><strong>Input</strong></p><ul><li>lag <code>l</code>, dependent variable <code>i</code>, regressor <code>j</code> in the VAR(<code>p</code>)</li><li><code>q[:,1]</code> and <code>q[:,2]</code> are [own, cross, lag, intercept] shrikages for the first <code>dQ</code> and remaining <code>dP-dQ</code> equations, respectively.</li><li><code>ν0</code>(d.f.), <code>Ω0</code>(scale): Inverse-Wishart prior for the error-covariance matrix of VAR(<code>p</code>).</li></ul><p><strong>Output</strong></p><ul><li>Minnesota part in the prior variance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/prior.jl#L117-L126">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.NIG_NIG-NTuple{6, Any}" href="#TermStructureModels.NIG_NIG-NTuple{6, Any}"><code>TermStructureModels.NIG_NIG</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NIG_NIG(y, X, β₀, B₀, α₀, δ₀)</code></pre><p>Normal-InverseGamma-Normal-InverseGamma update</p><ul><li>prior: <code>β|σ² ~ MvNormal(β₀,σ²B₀)</code>, <code>σ² ~ InverseGamma(α₀,δ₀)</code></li><li>likelihood: <code>y|β,σ² = Xβ + MvNormal(zeros(T,1),σ²I(T))</code></li></ul><p><strong>Output(2)</strong></p><p><code>β</code>, <code>σ²</code></p><ul><li>posterior sample</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/gibbs.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.PCs_2_latents-Tuple{Any, Any}" href="#TermStructureModels.PCs_2_latents-Tuple{Any, Any}"><code>TermStructureModels.PCs_2_latents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PCs_2_latents(yields, τₙ; κQ, kQ_infty, KₚF, GₚFF, ΩFF, data_scale)</code></pre><p>Notation <code>XF</code> is for the latent factor space and notation <code>F</code> is for the PC state space.</p><p><strong>Input</strong></p><ul><li><code>data_scale::scalar</code>: In typical affine term structure model, theoretical yields are in decimal and not annualized. But, for convenience(public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output(6)</strong></p><p><code>latent</code>, <code>κQ</code>, <code>kQ_infty</code>, <code>KₚXF</code>, <code>GₚXFXF</code>, <code>ΩXFXF</code></p><ul><li>latent factors contain initial observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L324-L332">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.S-Tuple{Any}" href="#TermStructureModels.S-Tuple{Any}"><code>TermStructureModels.S</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">S(i; Ω0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/EB_marginal.jl#L66-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.S_hat-NTuple{6, Any}" href="#TermStructureModels.S_hat-NTuple{6, Any}"><code>TermStructureModels.S_hat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">S_hat(i, m, V, yϕ, Xϕ, dP; Ω0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/EB_marginal.jl#L95-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.T0P-NTuple{4, Any}" href="#TermStructureModels.T0P-NTuple{4, Any}"><code>TermStructureModels.T0P</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T0P(T1X_, Aₓ_, Wₚ, c)</code></pre><p><strong>Input</strong></p><ul><li><code>T1X_</code> and <code>Aₓ_</code> are outputs of function <code>T1X</code> and <code>Aₓ</code>, respectively. <code>c</code> is a sample mean of <code>PCs</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>T0P</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L128-L134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.T1X-Tuple{Any, Any}" href="#TermStructureModels.T1X-Tuple{Any, Any}"><code>TermStructureModels.T1X</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">T1X(Bₓ_, Wₚ)</code></pre><p><strong>Input</strong></p><ul><li><code>Bₓ_</code> if an output of function <code>Bₓ</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>T1X</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L54-L60">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels._conditional_forecasts-NTuple{6, Any}" href="#TermStructureModels._conditional_forecasts-NTuple{6, Any}"><code>TermStructureModels._conditional_forecasts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_conditional_forecasts(S, τ, horizon, yields, macros, τₙ; κQ, kQ_infty, ϕ, σ²FF, Σₒ, mean_macros, data_scale)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/scenario.jl#L108-L110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels._scenario_analysis-NTuple{6, Any}" href="#TermStructureModels._scenario_analysis-NTuple{6, Any}"><code>TermStructureModels._scenario_analysis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_scenario_analysis(S, τ, horizon, yields, macros, τₙ; κQ, kQ_infty, ϕ, σ²FF, Σₒ, mean_macros, data_scale)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/scenario.jl#L348-L350">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels._scenario_analysis_unconditional-NTuple{5, Any}" href="#TermStructureModels._scenario_analysis_unconditional-NTuple{5, Any}"><code>TermStructureModels._scenario_analysis_unconditional</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_scenario_analysis_unconditional(τ, horizon, yields, macros, τₙ; κQ, kQ_infty, ϕ, σ²FF, Σₒ, mean_macros, data_scale)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/scenario.jl#L515-L517">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels._termPremium-NTuple{6, Any}" href="#TermStructureModels._termPremium-NTuple{6, Any}"><code>TermStructureModels._termPremium</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_termPremium(τ, PCs, macros, bτ_, T0P_, T1X_; κQ, kQ_infty, KₚF, GₚFF, ΩPP, data_scale)</code></pre><p>This function calculates a term premium for maturity <code>τ</code>. </p><p><strong>Input</strong></p><ul><li><code>data_scale::scalar</code> = In typical affine term structure model, theoretical yields are in decimal and not annualized. But, for convenience(public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output(4)</strong></p><p><code>TP</code>, <code>timevarying_TP</code>, <code>const_TP</code>, <code>jensen</code></p><ul><li><code>TP</code>: term premium of maturity <code>τ</code></li><li><code>timevarying_TP</code>: contributions of each <code>[PCs macros]</code> on <code>TP</code> at each time <span>$t$</span> (row: time, col: variable)</li><li><code>const_TP</code>: Constant part of <code>TP</code></li><li><code>jensen</code>: Jensen&#39;s Ineqaulity part in <code>TP</code></li><li>Output excludes the time period for the initial observations.  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L161-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels._unconditional_forecasts-NTuple{5, Any}" href="#TermStructureModels._unconditional_forecasts-NTuple{5, Any}"><code>TermStructureModels._unconditional_forecasts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_unconditional_forecasts(τ, horizon, yields, macros, τₙ; κQ, kQ_infty, ϕ, σ²FF, Σₒ, mean_macros, data_scale)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/scenario.jl#L43-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.aτ-NTuple{4, Any}" href="#TermStructureModels.aτ-NTuple{4, Any}"><code>TermStructureModels.aτ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aτ(N, bτ_, τₙ, Wₚ; kQ_infty, ΩPP, data_scale)
aτ(N, bτ_; kQ_infty, ΩXX, data_scale)</code></pre><p>The function has two methods(multiple dispatch). </p><p><strong>Input</strong></p><ul><li>When <code>Wₚ</code> ∈ arguments: It calculates <code>aτ</code> using <code>ΩPP</code>. </li><li>Otherwise: It calculates <code>aτ</code> using <code>ΩXX = ΩXFXF[1:dQ, 1:dQ]</code>, so parameters are in the latent factor space. So, we do not need <code>Wₚ</code>.</li><li><code>bτ_</code> is an output of function <code>bτ</code>.</li><li><code>data_scale::scalar</code>: In typical affine term structure model, theoretical yields are in decimal and not annualized. But, for convenience(public data usually contains annualized percentage yields) and numerical stability, we sometimes want to scale up yields, so want to use (<code>data_scale</code>*theoretical yields) as variable <code>yields</code>. In this case, you can use <code>data_scale</code> option. For example, we can set <code>data_scale = 1200</code> and use annualized percentage monthly yields as <code>yields</code>.</li></ul><p><strong>Output</strong></p><ul><li><code>Vector(Float64)(aτ,N)</code></li><li>For <code>i</code>&#39;th maturity, <code>Output[i]</code> is the corresponding <code>aτ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L65-L77">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.bτ-Tuple{Any}" href="#TermStructureModels.bτ-Tuple{Any}"><code>TermStructureModels.bτ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bτ(N; κQ)</code></pre><p>It solves the difference equation for <code>bτ</code>.</p><p><strong>Output</strong></p><ul><li>for maturity <code>i</code>, <code>bτ[:, i]</code> is a vector of factor loadings.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L24-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.jensens_inequality-Tuple{Any, Any, Any}" href="#TermStructureModels.jensens_inequality-Tuple{Any, Any, Any}"><code>TermStructureModels.jensens_inequality</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jensens_inequality(τ, bτ_, T1X_; ΩPP, data_scale)</code></pre><p>This function evaluate the Jensen&#39;s Ineqaulity term. All term is invariant with respect to the <code>data_scale</code>, except for this Jensen&#39;s inequality term. So, we need to scale down the term by <code>data_scale</code>.</p><p><strong>Output</strong></p><ul><li>Jensen&#39;s Ineqaulity term for <code>aτ</code> of maturity <code>τ</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/theoreticals.jl#L102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_kQ_infty-NTuple{4, Any}" href="#TermStructureModels.post_kQ_infty-NTuple{4, Any}"><code>TermStructureModels.post_kQ_infty</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">post_kQ_infty(μkQ_infty, σkQ_infty, yields, τₙ; κQ, ϕ, σ²FF, Σₒ, data_scale)</code></pre><p><strong>Output</strong></p><ul><li>Full conditional posterior distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/gibbs.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_Σₒ-Tuple{Any, Any}" href="#TermStructureModels.post_Σₒ-Tuple{Any, Any}"><code>TermStructureModels.post_Σₒ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">post_Σₒ(yields, τₙ; κQ, kQ_infty, ΩPP, γ, p, data_scale)</code></pre><p>Posterior sampler for the measurement errors</p><p><strong>Output</strong></p><ul><li><code>Vector{Dist}(IG, N-dQ)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/gibbs.jl#L149-L154">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_γ-Tuple{}" href="#TermStructureModels.post_γ-Tuple{}"><code>TermStructureModels.post_γ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">post_γ(; γ_bar, Σₒ)</code></pre><p>Posterior sampler for the population measurement error</p><p><strong>Output</strong></p><ul><li><code>Vector{Dist}(Gamma,length(Σₒ))</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/gibbs.jl#L182-L187">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_κQ-Tuple{Any, Any, Any}" href="#TermStructureModels.post_κQ-Tuple{Any, Any, Any}"><code>TermStructureModels.post_κQ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">post_κQ(yields, prior_κQ_, τₙ; kQ_infty, ϕ, σ²FF, Σₒ, data_scale)</code></pre><p><strong>Input</strong></p><ul><li><code>prior_κQ_</code> is a output of function <code>prior_κQ</code>.</li></ul><p><strong>Output</strong></p><ul><li>Full conditional posterior distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/gibbs.jl#L48-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.post_ϕ_σ²FF-NTuple{6, Any}" href="#TermStructureModels.post_ϕ_σ²FF-NTuple{6, Any}"><code>TermStructureModels.post_ϕ_σ²FF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">post_ϕ_σ²FF(yields, macros, μϕ_const, ρ, prior_κQ_, τₙ; ϕ, ψ, ψ0, σ²FF, q, ν0, Ω0, κQ, kQ_infty, Σₒ, fix_const_PC1, data_scale)</code></pre><p>Full-conditional posterior sampler for <code>ϕ</code> and <code>σ²FF</code> </p><p><strong>Input</strong></p><ul><li><code>prior_κQ_</code> is a output of function <code>prior_κQ</code>.</li><li>When <code>fix_const_PC1==true</code>, the first element in a constant term in our orthogonalized VAR is fixed to its prior mean during the posterior sampling.</li></ul><p><strong>Output(3)</strong></p><p><code>ϕ</code>, <code>σ²FF</code>, <code>isaccept=Vector{Bool}(undef, dQ)</code></p><ul><li>It gives a posterior sample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/gibbs.jl#L73-L82">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.prior_C-Tuple{}" href="#TermStructureModels.prior_C-Tuple{}"><code>TermStructureModels.prior_C</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prior_C(; Ω0::Vector)</code></pre><p>We translate the Inverse-Wishart prior to a series of the Normal-Inverse-Gamma (NIG) prior distributions. If the dimension is dₚ, there are dₚ NIG prior distributions. This function generates Normal priors.  </p><p><strong>Output:</strong></p><ul><li>unscaled prior of <code>C</code> in the LDLt decomposition, <code>ΩFF = inv(C)*diagm(σ²FF)*inv(C)&#39;</code></li></ul><p><strong>Important note</strong></p><p>prior variance for <code>C[i,:] = σ²FF[i]*variance of output[i,:]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/prior.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.prior_γ-Tuple{Any, Any}" href="#TermStructureModels.prior_γ-Tuple{Any, Any}"><code>TermStructureModels.prior_γ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prior_γ(yields, p)</code></pre><p>There is a hierarchcal structure in the measurement equation. The prior means of the measurement errors are <code>γ[i]</code> and each <code>γ[i]</code> follows Gamma(1,<code>γ_bar</code>) distribution. This function decides <code>γ_bar</code> empirically. OLS is used to estimate the measurement equation and then a variance of residuals is calculated for each maturities. An inverse of the average residual variances is set to <code>γ_bar</code>.</p><p><strong>Output</strong></p><ul><li>hyperparameter <code>γ_bar</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/prior.jl#L194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.prior_σ²FF-Tuple{}" href="#TermStructureModels.prior_σ²FF-Tuple{}"><code>TermStructureModels.prior_σ²FF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prior_σ²FF(; ν0, Ω0::Vector)</code></pre><p>We translate the Inverse-Wishart prior to a series of the Normal-Inverse-Gamma (NIG) prior distributions. If the dimension is dₚ, there are dₚ NIG prior distributions. This function generates Inverse-Gamma priors.  </p><p><strong>Output:</strong></p><ul><li>prior of <code>σ²FF</code> in the LDLt decomposition,<code>ΩFF = inv(C)*diagm(σ²FF)*inv(C)&#39;</code></li><li>Each element in the output follows Inverse-Gamma priors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/prior.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.prior_ϕ0-Tuple{Any, Vector{T} where T, Any, Any, Any}" href="#TermStructureModels.prior_ϕ0-Tuple{Any, Vector{T} where T, Any, Any, Any}"><code>TermStructureModels.prior_ϕ0</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prior_ϕ0(μϕ_const, ρ::Vector, prior_κQ_, τₙ, Wₚ; ψ0, ψ, q, ν0, Ω0, fix_const_PC1)</code></pre><p>This part derives the prior distribution for coefficients of the lagged regressors in the orthogonalized VAR. </p><p><strong>Input</strong></p><ul><li><code>prior_κQ_</code> is a output of function <code>prior_κQ</code>.</li><li>When <code>fix_const_PC1==true</code>, the first element in a constant term in our orthogonalized VAR is fixed to its prior mean during the posterior sampling.</li></ul><p><strong>Output</strong></p><ul><li>Normal prior distributions on the slope coefficient of lagged variables and intercepts in the orthogonalized equation. </li><li><code>Output[:,1]</code> for intercepts, <code>Output[:,1+1:1+dP]</code> for the first lag, <code>Output[:,1+dP+1:1+2*dP]</code> for the second lag, and so on.</li></ul><p><strong>Important note</strong></p><p>prior variance for <code>ϕ[i,:]</code> = <code>σ²FF[i]*var(output[i,:])</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/prior.jl#L50-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.yϕ_Xϕ-Tuple{Any, Any, Any}" href="#TermStructureModels.yϕ_Xϕ-Tuple{Any, Any, Any}"><code>TermStructureModels.yϕ_Xϕ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">yϕ_Xϕ(PCs, macros, p)</code></pre><p>This function generate the dependent variable and the corresponding regressors in the orthogonalized transition equation.</p><p><strong>Output(4)</strong></p><p><code>yϕ</code>, <code>Xϕ = [ones(T - p) Xϕ_lag Xϕ_contemporaneous]</code>, <code>[ones(T - p) Xϕ_lag]</code>, <code>Xϕ_contemporaneous</code></p><ul><li><code>yϕ</code> and <code>Xϕ</code> is a full matrix. For i&#39;th equation, the dependent variable is <code>yϕ[:,i]</code> and the regressor is <code>Xϕ</code>. </li><li><code>Xϕ</code> is same to all orthogonalized transtion equations. The orthogonalized equations are different in terms of contemporaneous regressors. Therefore, the corresponding regressors in <code>Xϕ</code> should be excluded. The form of parameter <code>ϕ</code> do that task by setting the coefficients of the excluded regressors to zeros. In particular, for last <code>dP</code> by <code>dP</code> block in <code>ϕ</code>, the diagonals and the upper diagonal elements should be zero. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.ν-Tuple{Any, Any}" href="#TermStructureModels.ν-Tuple{Any, Any}"><code>TermStructureModels.ν</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ν(i, dP; ν0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/EB_marginal.jl#L59-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.ϕ_hat-NTuple{6, Any}" href="#TermStructureModels.ϕ_hat-NTuple{6, Any}"><code>TermStructureModels.ϕ_hat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ϕ_hat(i, m, V, yϕ, Xϕ, dP)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/EB_marginal.jl#L82-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="TermStructureModels.ϕ_σ²FF_2_ΩPP-Tuple{}" href="#TermStructureModels.ϕ_σ²FF_2_ΩPP-Tuple{}"><code>TermStructureModels.ϕ_σ²FF_2_ΩPP</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ϕ_σ²FF_2_ΩPP(; ϕ, σ²FF)</code></pre><p>It construct <code>ΩPP</code> from statistical parameters.</p><p><strong>Output</strong></p><ul><li><code>ΩPP</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/econPreference/TermStructureModels.jl/blob/f79084d5ff9f9050c0660148cc1506520210b02f/src/empiricals.jl#L108-L113">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Thursday 1 February 2024 13:43">Thursday 1 February 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
