<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · TermStructureModels.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>TermStructureModels.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Prerequisites"><span>Prerequisites</span></a></li><li><a class="tocitem" href="#Model"><span>Model</span></a></li><li><a class="tocitem" href="#Estimation"><span>Estimation</span></a></li><li><a class="tocitem" href="#Inference"><span>Inference</span></a></li><li><a class="tocitem" href="#Structs-in-the-packages"><span>Structs in the packages</span></a></li><li><a class="tocitem" href="#Introducing-a-sparsity-on-error-precision-matrix"><span>Introducing a sparsity on error precision matrix</span></a></li><li><a class="tocitem" href="#Yield-curve-interpolation"><span>Yield curve interpolation</span></a></li><li><a class="tocitem" href="#Term-premium"><span>Term premium</span></a></li><li><a class="tocitem" href="#Scenario-Analysis-and-unconditional-forecasts"><span>Scenario Analysis and unconditional forecasts</span></a></li></ul></li><li><a class="tocitem" href="api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/econPreference/TermStructureModels.jl/blob/main/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TermStructureModels.jl"><a class="docs-heading-anchor" href="#TermStructureModels.jl">TermStructureModels.jl</a><a id="TermStructureModels.jl-1"></a><a class="docs-heading-anchor-permalink" href="#TermStructureModels.jl" title="Permalink"></a></h1><p><strong>NOTE. As I am currently in the job market, the completion of the documentation has been delayed. I will finish the work in February. Thanks.</strong></p><p>No-Arbitrage Term Structure Models are theoretical government bond models where the bond price satisfies the no-arbitrage condition. It is a Gaussian model because all shocks follow Normal distributions. <strong>GDTSM.jl</strong> is a package for estimating the GDTSM. I follow the three-factor GDTSM of Joslin, Singleton, and Zhu (JSZ, 2011).</p><p>The <strong>main features</strong> of the package are</p><ul><li>Bayesian Estimation with automatically tuned hyper-parameters in a data-driven way (including VAR(p) lag selection)</li><li>Yield curve interpolation and fitting</li><li>Decomposition of a bond yield into the expectation hypothesis component and the term premium component</li><li>The capability of accommodating unspanned macro risks</li><li>Scenario Analyses and unconditional forecasts under the large-scale VAR framework to inspect interactions between bond yields and the macroeconomy</li></ul><p>If you have any suggestions, please feel free to ask me by raising issues.</p><h2 id="Prerequisites"><a class="docs-heading-anchor" href="#Prerequisites">Prerequisites</a><a id="Prerequisites-1"></a><a class="docs-heading-anchor-permalink" href="#Prerequisites" title="Permalink"></a></h2><p>Since we use two R packages (GIGrvg, glasso), users have to install R language. If you already have experience using RCall.jl, you just need to install the two R Packages. If it is the first time using RCall.jl, follow the below steps.</p><ol><li>Install R on your computer from the internet.</li><li>In R, run the below command and copy the home address.</li></ol><pre><code class="language-R hljs">R.home()</code></pre><ol><li>In R, run the below code to install the packages.</li></ol><pre><code class="language-R hljs">install.packages(&quot;GIGrvg&quot;)
install.packages(&quot;glasso&quot;)</code></pre><ol><li>In Juila, run</li></ol><pre><code class="language-juila hljs">ENV[&quot;R_HOME&quot;]=&quot;&quot;</code></pre><ol><li>In Juila, run</li></ol><pre><code class="language-juila hljs">ENV[&quot;PATH&quot;]=&quot;...the address in step 2...&quot;</code></pre><ol><li>In Juila, run</li></ol><pre><code class="language-juila hljs">using Pkg
Pkg.add(&quot;RCall&quot;)</code></pre><h2 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h2><p>We follow the JSZ form, but with the restriction that Q-eigenvalues are [1, exp( <span>$- \kappa^\mathbb{Q}$</span>), exp( <span>$- \kappa^\mathbb{Q}$</span>)]. In this case, <span>$\kappa^\mathbb{Q}$</span> is statistically equivalent to the decay parameter of the Dynamic Nelson-Siegel model (Diebold and Li, 2006). That is, our restricted JSZ model is statistically equivalent to the AFNS model (Christensen, Diebold, and Rudebusch, 2011).</p><p>Despite the AFNS restriction, our theoretical model sustains the JSZ form. The latent factors in our JSZ model are transformed into the principal components. And then, we estimate the model with the transformed state space as the JSZ did. One major difference between JSZ and ours is that we use the Bayesian methodology. For details, see our paper.</p><h2 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h2><p><strong>Note that all yield data should be annual percentage data (i.e. yield data = 1200 <span>$\times$</span> theoretical yield in the model).</strong></p><h3 id="Step1.-Tuning-hyper-parameters"><a class="docs-heading-anchor" href="#Step1.-Tuning-hyper-parameters">Step1. Tuning hyper-parameters</a><a id="Step1.-Tuning-hyper-parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Step1.-Tuning-hyper-parameters" title="Permalink"></a></h3><p>We have four hyper-parameters, <span>$p$</span>, <span>$q$</span>, <span>$\nu_0$</span>, and <span>$\Omega_0$</span>.</p><ul><li><p class="math-container">\[p\]</p>(Float64): lag of the VAR(p) in <span>$\mathbb{P}$</span> -measure</li><li><p class="math-container">\[q\]</p>(Vector) <span>$=$</span> [ <span>$q_1$</span>; <span>$q_2$</span>; <span>$q_3$</span>; <span>$q_4$</span>]: Minnesota prior<ul><li>Prior variances of slopes <span>$\propto$</span> <span>$q_1$</span>/ <span>${lag}^{q_3}$</span> (for own lagged variables) or <span>$q_2$</span>/ <span>${lag}^{q_3}$</span> (for cross lagged variables)</li><li>Prior variances of intercepts <span>$\propto$</span> <span>$q_4$</span></li></ul></li><li><p class="math-container">\[\nu_0\]</p>(Float64), <span>$\Omega_0$</span>(Vector): Error covariance of VAR(p) <span>$\backsim$</span> InverseWishart(<span>$\nu_0$</span>, <span>$\Omega_0$</span>)</li></ul><p>We have additional two hyper-parameters that can be decided more objectively.</p><ul><li><p class="math-container">\[\rho\]</p>(Vector): ρ is a vector that has a size of size(macros,2). If <span>$i$</span>&#39;th variable in macros is a growth(or level) variable, <span>$\rho$</span>[i] = 0(or <span>$\approx$</span> 1) should be set.</li><li>medium_τ(Vector): Candidate maturities where the curvature factor loading is maximized. The default value is <a href="months">12, 18, 24, 30, 36, 42, 48, 54, 60</a>. When you estimate quarterly or annual data, this value should be modified.</li></ul><p>Struct &quot;HyperParameter(<span>$p$</span>, <span>$q$</span>, <span>$\nu_0$</span>, <span>$\Omega_0$</span>)&quot; contains hyper-parameter values. We have a function &quot;tuning_hyperparameter&quot; that generates struct &quot;HyperParameter&quot; in a data-driven way (Chan, 2022).</p><pre><code class="language-juila hljs">tuned = tuning_hyperparameter(yields, macros, ρ)</code></pre><p>When using the function, T by N matrix &quot;yields&quot; and T by M matrix &quot;macros&quot; should contain initial observations (<span>$t$</span> = 0, -1, -2, <span>$\cdots$</span>).</p><p>You can maximize the model selection criterion (marginal likelihood) directly if you want to. The objective function is</p><pre><code class="language-juila hljs">log_marginal(PCs, macros, ρ, tuned::HyperParameter; medium_τ = 12 * [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5])</code></pre><p>Here, the objective is maximized over &quot;tuned&quot;, and initial observations also should be included. &quot;PCs&quot; are the first, second, and third principal components of yields. We have a function for the principal component analysis.</p><pre><code class="language-juila hljs">PCs, OCs, Wₚ, Wₒ = PCA(yields, p; rescaling=true)</code></pre><p>The function uses eigenVectors of cov(yields[p+1:end,:]) to transform yields[1:end, :] to PCs. When rescaling = true, standard deviations of all PCs are normalized to an average of standard deviations of yields. Here, PCs and OCs are the first three and remaining principal components, respectively. Also, PCs[t, :] = Wₚ <span>$\times$</span> yields[t, :] and OCs[t, :] = Wₒ <span>$\times$</span> yields[t, :] hold.</p><h3 id="Step-2.-sampling-the-posterior-distribution-of-GDTSM"><a class="docs-heading-anchor" href="#Step-2.-sampling-the-posterior-distribution-of-GDTSM">Step 2. sampling the posterior distribution of GDTSM</a><a id="Step-2.-sampling-the-posterior-distribution-of-GDTSM-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2.-sampling-the-posterior-distribution-of-GDTSM" title="Permalink"></a></h3><pre><code class="language-juila hljs">saved_θ, acceptPr_C_σ²FF, acceptPr_ηψ = posterior_sampler(yields, macros, τₙ, ρ, iteration, tuned::HyperParameter; sparsity=false, medium_τ=12 * [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5], init_param=[])</code></pre><p>When using the function, T by N matrix &quot;yields&quot; and T by M matrix &quot;macros&quot; should contain initial observations (<span>$t$</span> = 0, -1, -2, <span>$\cdots$</span>). τₙ is a vector that contains observed maturities of &quot;yields&quot;. &quot;Iteration&quot; is the number of Gibbs sampling samples. Function &quot;posterior<em>sampler&quot; generate a vector of struct &quot;Parameter&quot;s that contains posterior samples. The second and third outputs say an MH acceptance probability of { \phi</em>{i}<span>$, $σ²_{FF,i}$</span>: <span>$i = 1$</span>, <span>$\cdots$</span>, <span>$d_\mathbb{Q}$</span> } and ηψ, respectively.</p><p>When &quot;sparsity = true&quot;, we introduce additional Normal-Gamma(NG) priors on the intercepts and slopes while maintaining the Minnesota prior (Chan, 2021). The NG prior leads to the Generalized Inverse Gaussian posterior distribution. To sample this posterior, we use R package &quot;GIGrvg&quot; (Hörmann and Leydold, 2014).</p><p>We provide a default starting point for the sampler. However, if you want to set it, use keyward &quot;init_param&quot; that should be struct &quot;Parameter&quot;.</p><h2 id="Inference"><a class="docs-heading-anchor" href="#Inference">Inference</a><a id="Inference-1"></a><a class="docs-heading-anchor-permalink" href="#Inference" title="Permalink"></a></h2><p>To call posterior samples of objects in structs (&quot;Parameter&quot;, &quot;ReducedForm&quot; &quot;LatentSpace&quot;, &quot;YieldCurve&quot;, &quot;TermPremium&quot;, and &quot;Forecast&quot;), use [:name]. For example, for output &quot;saved_θ&quot; of function &quot;posterior sampler&quot;,</p><pre><code class="language-juila hljs">samples = saved_θ[:κQ]
samples[i] # i&#39;th posterior sample of κQ</code></pre><p>The variable names in structs &quot;Parameter&quot;, &quot;ReducedForm&quot;, and &quot;LatentSpace&quot; represent</p><ul><li>κQ: <span>$\kappa^{\mathbb{Q}}$</span>,</li><li>kQ<em>infty: k^{\mathbb{Q}}</em>{\infty}$,</li><li>ϕ: { <span>$\phi_{i}$</span>; <span>$i$</span> <span>$=$</span> <span>$1$</span>, <span>$\cdots$</span>, <span>${d}_{\mathbb{P}}$</span> },</li><li>σ²FF: { <span>$\sigma^2_{\mathcal{FF},i}$</span> ; <span>$i$</span> <span>$=$</span> <span>$1$</span>, <span>$\cdots$</span>, <span>$d_\mathbb{P}$</span> },</li><li>ηψ: <span>$\eta_{\psi}$</span>,</li><li>ψ: <span>$d_\mathbb{P}$</span> by <span>${p}{\cdot}$</span> <span>$d_{\mathbb{P}}$</span> Matrix, [[ <span>$\psi_{1,i,j}$</span> ] <span>$\cdots$</span> [ <span>$\psi_{p,i,j}$</span> ] ]</li><li>ψ0: { <span>$\psi_{0,i}$</span> : <span>$i=1$</span>, <span>$\cdots$</span>, <span>$d_\mathbb{P}$</span> }</li><li>Σₒ: <span>$\Sigma_{\mathcal{O}}$</span></li><li>γ: { <span>$\gamma_i$</span> : <span>$i=1$</span>, <span>$\cdots$</span>, N - <span>$d_\mathbb{Q}$</span> }</li><li>KₚF: <span>$K^\mathbb{P}_\mathcal{F}$</span></li><li>GₚFF: [ <span>$G^P_{\mathcal{FF},1}$</span> <span>$\cdots$</span> <span>$G^P_{\mathcal{FF},p}$</span> ]</li><li>ΩFF: <span>$\Omega_\mathcal{FF}$</span></li><li>λP: <span>$\lambda_\mathcal{P}$</span></li><li>ΛPF: [[<span>$\Lambda_{\mathcal{PP},1}$</span>, <span>$\Lambda_{\mathcal{P}M,1}$</span>] <span>$\cdots$</span> [ <span>$\Lambda_{\mathcal{PP},p}$</span>, <span>$\Lambda_{\mathcal{P}M,p}$</span>]]</li><li>KₚXF: <span>$K^\mathbb{P}_F$</span></li><li>GₚXFXF: [ <span>$G^P_{FF,1}$</span> <span>$\cdots$</span> <span>$G^P_{FF,p}$</span> ]</li><li>ΩXFXF: <span>$\Omega_{FF}$</span></li></ul><p>in our paper. Parameters in &quot;ReducedForm&quot; and &quot;LatentSpace&quot; can be deduced by using functions &quot;reducedform&quot; and &quot;latentspace&quot;, respectively. &quot;ReducedForm&quot; contains the reduced form VAR(p) parameters. &quot;LatentSpace&quot; contains parameters when our model is expressed in terms of latent factor <span>$X_t$</span></p><p>We support mean(), var(), std(), median(), quantile() in Statistics.jl. So, for example, when we need a posterior mean,</p><pre><code class="language-juila hljs">mean(saved_θ)[:kQ_infty]</code></pre><p>gives the corresponding posterior mean of kQ_infty. All functions, [:name], <span>$\cdots$</span>, quantile(), can be run on six structs, which are &quot;Parameter&quot;, &quot;ReducedForm&quot; &quot;LatentSpace&quot;, &quot;YieldCurve&quot;, &quot;TermPremium&quot;, and &quot;Forecast&quot;.</p><h2 id="Structs-in-the-packages"><a class="docs-heading-anchor" href="#Structs-in-the-packages">Structs in the packages</a><a id="Structs-in-the-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Structs-in-the-packages" title="Permalink"></a></h2><p>To see names of objects in the structs, run, for example,</p><pre><code class="language-juila hljs">help?&gt;YieldCurve</code></pre><p>We have eight structs, which are <strong>HyperParameter</strong>, <strong>Parameter</strong>, <strong>ReducedForm</strong>, <strong>LatentSpace</strong>, <strong>YieldCurve</strong>, <strong>TermPremium</strong>, <strong>Scenario</strong>, and <strong>Forecast</strong>. It also provides details of the structs.</p><h2 id="Introducing-a-sparsity-on-error-precision-matrix"><a class="docs-heading-anchor" href="#Introducing-a-sparsity-on-error-precision-matrix">Introducing a sparsity on error precision matrix</a><a id="Introducing-a-sparsity-on-error-precision-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Introducing-a-sparsity-on-error-precision-matrix" title="Permalink"></a></h2><pre><code class="language-juila hljs">sparse_θ, trace_λ, trace_sparsity = sparse_prec(saved_θ::Vector{Parameter}, yields, macros, τₙ)</code></pre><p>It introduces a sparsity on the error precision matrix of VAR(p) P-dynamics using Freidman, Hastie, and Tibshirani (2008) and Hauzenberger, Huber, and Onorante (2021). We use R-package &quot;glasso&quot; to implement it. Specifically, the additionally introduced lasso penalty makes some small elements in the precision to zero.</p><p>Here, the data should contain initial observations. τₙ is a vector that contains observed maturities of &quot;yields&quot;. &quot;saved<em>θ&quot; is an output of function &quot;posterior sampler&quot;. For the outputs, &quot;sparse</em>θ&quot; is also a vector of struct &quot;Parameter&quot; but has sparse precision matrices. &quot;trace<em>λ&quot; and &quot;trace</em>sparsity&quot; contain the used optimal penalty parameter and the number of non-zero elements of the precision.</p><h2 id="Yield-curve-interpolation"><a class="docs-heading-anchor" href="#Yield-curve-interpolation">Yield curve interpolation</a><a id="Yield-curve-interpolation-1"></a><a class="docs-heading-anchor-permalink" href="#Yield-curve-interpolation" title="Permalink"></a></h2><pre><code class="language-juila hljs">fitted = fitted_YieldCurve(τ0, saved_Xθ::Vector{LatentSpace})</code></pre><p>To derive the fitted yield curve, you first derive &quot;saved_Xθ&quot; from function &quot;latentspace&quot;. τ0 is a vector that contains maturities of interest. The output is Vector{&quot;YieldCurve&quot;}.</p><h2 id="Term-premium"><a class="docs-heading-anchor" href="#Term-premium">Term premium</a><a id="Term-premium-1"></a><a class="docs-heading-anchor-permalink" href="#Term-premium" title="Permalink"></a></h2><pre><code class="language-juila hljs">saved_TP = term_premium(τ, τₙ, saved_θ::Vector{Parameter}, yields, macros)</code></pre><p>The function calculates term premium estimates of maturity τ (months). Here, τ does not need to be the one in τₙ. &quot;τₙ&quot;, &quot;yields&quot;, and &quot;macros&quot; are the things that were inputs of function &quot;posterior sampler&quot;. &quot;saved<em>θ&quot; is the output of function &quot;posterior sampler&quot;. Output &quot;saved</em>TP&quot; is Vector{TermPremium}.</p><h2 id="Scenario-Analysis-and-unconditional-forecasts"><a class="docs-heading-anchor" href="#Scenario-Analysis-and-unconditional-forecasts">Scenario Analysis and unconditional forecasts</a><a id="Scenario-Analysis-and-unconditional-forecasts-1"></a><a class="docs-heading-anchor-permalink" href="#Scenario-Analysis-and-unconditional-forecasts" title="Permalink"></a></h2><pre><code class="language-juila hljs">prediction = scenario_sampler(S::Scenario, τ, horizon, saved_θ, yields, macros, τₙ)</code></pre><p>The function generates (un)conditional forecasts using our model. We use the Kalman filter to make conditional filtered forecasts (Bańbura, Giannone, and Lenza, 2015), and then we use Kim and Nelson (1999) to make smoothed posterior samples of the conditional forecasts. &quot;S&quot; is a conditioned scenario, and yields, risk factors, and a term premium of maturity &quot;τ&quot; are forecasted. &quot;horizon&quot; is a forecasting horizon. &quot;τₙ&quot;, &quot;yields&quot;, and &quot;macros&quot; are the things that were inputs of function &quot;posterior sampler&quot;. &quot;saved_θ&quot; is an output of function &quot;posterior sampler&quot;. The output is Vector{Forecast}.</p><p>Struct Scenario has two elements, &quot;combinations&quot; and &quot;values&quot;. Meaning of the struct can be found by help? command. Examples of making struct &quot;Scenario&quot; are as follows.</p><pre><code class="language-juila hljs"># Case 1. Unconditional Forecasts
S = []

# Case 2. Scenario with one conditioned variable and time length 2
comb = zeros(1, size([yields macros], 2))
comb[1, 1] = 1.0 # one month yield is selected as a conditioned variable
values = [3.0] # Scenario: one month yield at time T+1 is 3.0
S = Scenario(combinations=comb, values=values)

# Case 3. Scenario with two conditioned combinations and time length 3
comb = zeros(2, size([yields macros], 2), 3)
values = zeros(2, 3)
for t in 1:3 # for simplicity, we just assume the same scenario for time = T+1, T+2, T+3. Users can freely assume different scenarios for each time T+t.
  comb[1, 1, t] = 1.0 # one month yield is selected as a conditioned variable in the first combination
  comb[2, 20, t] = 0.5
  comb[2, 21, t] = 0.5 # the average of 20th and 21st observables is selected as a second conditioned combination
  values[1,t] = 3.0 # one month yield at time T+t is 3.0
  values[2,t] = 0.0 # the average value is zero.
end
S = Scenario(combinations=comb, values=values)</code></pre><p>Here, <strong>both &quot;combinations&quot; and &quot;values&quot; should be type Array{Float64}</strong>. Also, &quot;horizon&quot; should not be smaller than size(values, 2).</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 3 February 2024 02:31">Saturday 3 February 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
